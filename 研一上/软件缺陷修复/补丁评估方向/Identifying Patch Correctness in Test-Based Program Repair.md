# 	笔记模板2

## 1. 文章解决的问题

本文的目标是在不知道完整的test oracle的情况下对补丁进行启发式分类。

该文章就是提出了一个方案，生成新的测试输入，执行路径与之前的测试集进行对比，利用算法将测试进行分类，再进行补丁的分类。

基于程序执行的行为相似性来自动判断补丁正确性

## 2. 解决的思路

文章基于两种关键的观察来实现的。

1. PATCH-SIM：应用补丁前与补丁后的程序，对于成功的测试用例来说是没区别或相似的。但是对于错误的补丁是有很大的区别的。这是一个基准
2. TEST-SIM：两个测试用例有相似的执行时，那么两个都触发了相同的错误或都正确。这个可以用来生成新的测试用例

两个还是有一定的依据的：

第二点：弱输入导致找不到错误的补丁：在defts4j中Lang-39中，APR产生的补丁依据repeat的true or false来决定是否遍历循环的。恰好的是通过的测试用例的repeat全是true，失败的测试用例全是false。但是真正的错误却不是因为repeat的原因。

当新测试输入的执行类似于失败的测试用例，那么新的测试输出很可能导致失败。否则就会成功

基于上面的两个observation，有以下三个步骤来解决文章的问题

* first，生成新的测试用例
* second， 将新的测试输入（==注：不是测试用例==）与原有的测试输入进行比较来将新生成的测试用例来分类为成功或失败（根据TEST-SIM）
* 然后用PATCH-SIM来比较使用补丁前后程序的执行来确定补丁的正确性。

## 3. 核心知识点或名词定义

1. test oracles ：测试准则。一个测试用例 = 测试输入 + 测试准则，也就是说test oracles是提供一个标准，检查程序的输出是否正确。
2. 补丁排名：补丁排名与补丁分类不是同一个，但是可以通过对排名进行一个阈值
3. 文章假定程序只包含一个错误，失败的测试用例暴露出这个bug。（如果有多个故障，那么假定失败测试用例只能找到一个bug，将其余bug视为正确的）
4. 文章假定补丁定义为一对程序版本：有bug的源程序和有补丁的修复程序
5. ==执行==的相似：本文采用完整路径谱(complete-path spectrum)的方法来确定相似性（程序执行期间执行语句的id序列）。

## 4.程序功能说明

程序的概要图

<img src="C:\Users\HDULAB601\AppData\Roaming\Typora\typora-user-images\image-20211027164521019.png" alt="image-20211027164521019" style="zoom:67%;" />

1. test generation：为了确定补丁的正确性，生成的测试输入必须覆盖补丁的方法。如果补丁修改了多个方法，则必须覆盖其中一个。利用符号执行来覆盖特点方法。利用随机测试技术来筛选测试

2. Distance measurement:

   * 执行（execution）距离计算：使用两个路径序列的最大公共子序列

   ![image-20211027191241473](C:\Users\HDULAB601\AppData\Roaming\Typora\typora-user-images\image-20211027191241473.png)

   * 测试距离计算：每个新生成的测试输入得到的距离都是一个向量，向量的每一位都是这个测试输入与原来的测试输入的距离。==注：在bug程序上执行==
   * 补丁的距离计算也是类似于测试距离计算：测试t在使用补丁前后的程序中进行距离计算

3. 分类

   * 测试分类：

     <img src="C:\Users\HDULAB601\AppData\Roaming\Typora\typora-user-images\image-20211027194312175.png" alt="image-20211027194312175" style="zoom:67%;" />

   * 补丁的分类：

     <img src="C:\Users\HDULAB601\AppData\Roaming\Typora\typora-user-images\image-20211027195432322.png" alt="image-20211027195432322" style="zoom:67%;" />

     两个条件：1. 在通过的测试中选择最大的距离，如果这个距离大于$$K_p$$这个阈（yu）值或者大于失败的测试的最小距离。那么这个补丁就错了

     

   
   结果：PATCH-SIM：是可以用来区分一个补丁的准确性
   
   ​           TEST-SIM ：在一般情况下也成立
   
   面对收集到的补丁，没有将任何一个正确的补丁归类到错误的补丁里。能够过滤掉56.3%的错误补丁
   
   实验中产生错误的一些原因：
   
   1. 没有将错误的补丁找出来：通常情况下，只有一个失败的测试覆盖了修补过的方法。也就是弱测试集
   2. 测试的生成工具不够强大
   3. 分类公式不够强大
   
   



## 5. 存在的问题

这个方法有一个风险：将正确的补丁认为是错误的补丁，因为没有一个完美的oracle

## 6. 改进的思路或相关工作

1. 利用KATCH这个方法来提高生成测试用例的质量（Marinescu and Cadar这两个人提出的）
2. 基于突变的故障修复对PATCH-SIM的假设有类似的结论：如果bug语句有了个基于突变的补丁，通过的测试用例在补丁使用前后的变化幅度是远小于失败的测试用例（Metallaxis and MUSE 提出的）
   1. 冗余的测试用例

3. 执行距离的计算是不是应该加个权值。bug语句可能性高的权值更大

