# 笔记模板2

## 1. 文章解决的问题

本文目标是计算代码可疑度时，考虑每个附加测试用例的贡献。

一个假设：当一段代码（或一条语句）被900个成功的测试用例执行后，那第901个成功的测试用例执行后的贡献（==信息与花费的资源比例？==）很可能小于之前的测试用例。当执行900次后，很难再拿出新的信息。这也适用于错误的测试用例。

基本方法：给定一段代码和一个bug。找到该bug在该代码段中的可能性。

## 2. 解决的思路

1. 当出现程序偏离预期的行为时，一般开发者有两种操作：分析内存转储、在可疑代码周围打印变量值

2. 设一条语句s，一个bug：b。现在要求b在s中的可能性。

   * 对于第j条语句的可疑度：失败的测试用例数（只有执行了j这条语句的失败测试用例）

   <img src="C:\Users\HDULAB601\AppData\Roaming\Typora\typora-user-images\image-20220307193541486.png" alt="image-20220307193541486" style="zoom:67%;" />

   * 当成功的测试用例执行一条语句时，则该语句的可疑度越小。那么现在有第二种可疑度计算公式：

     失败的测试用例 - 成功的测试用例（都执行了第j条语句）。缺点：（一个失败的测试用例和一个成功的测试用例）、（10个失败的测试用例和10个成功的测试用例）无法区别以上两种

   * 现在执行语句s的失败的测试用例一共n个，将n分为多个组，第一个组最多分到1个测试用例，第二个组分到2个失败的测试用例，以此类推。

     ![image-20220307201706624](C:\Users\HDULAB601\AppData\Roaming\Typora\typora-user-images\image-20220307201706624.png)

     $$W_{F,1} = 1,W_{F,2} = 0.1, W_{F,3} = 0.01$$,$$n_{F,1} = n_{S,1} = 2, n_{F,2} = n_{S,2} = 4$$
     
     $$W_{S,1} = 1, W_{S,2} = 0.1, W_{S,3} = \lambda *  \chi_{F/S}$$。其中$$\lambda$$越小则S这条语句就越可疑。
     
     

## 3. 核心知识点或名词定义

<img src="C:\Users\HDULAB601\AppData\Roaming\Typora\typora-user-images\image-20220307191852148.png" alt="image-20220307191852148" style="zoom:80%;" />

其中contribution在文中好像也没说明是什么意思，但是反映在数值上的就是权重。

## 4.程序功能说明

## 5. 存在的问题

## 6. 改进的思路

## 7. 想法来源

