# 笔记模板1

## 1. 自我提问

* 什么是extension point
* 什么是explicit design space of generate-and-validate program re- 
  pair
* Astor是什么

## 2. 自我解答

1. 指在当前对应的扩展点中可以选择已经存在的技术，也可以自己加入新的技术来实现扩展点对应的功能。比如缺陷定位，可以用Astor中集成好的技术，也可以用自己的技术
2. s
3. Astor是一个框架，集成了6个修复方法：jGenProg, jKali, jMutRepair, MutRepair, DeepRepair, Cardumen.

## 3. 文章的核心问题与思路



## 4. 可能改进的地方

## 5. 文章流程图

## 6. 算法流程图

![image-20211025183033152](C:\Users\HDULAB601\AppData\Roaming\Typora\typora-user-images\image-20211025183033152.png)

* EP_MPG这个地方指根据前面的缺陷定位，来设置一个修改点。其中它的好处就是可以确定粒度大小，比如修改一个符号或者一条语句。根据不同缺陷定位技术是对应不同的修改粒度。
* 修复操作(repair operator): 将修改点的代码元素转换成修改后的代码元素
  * 一种是直接将一个操作符应用在一个修改点，比如使用jMutRepair,将 > 换成>=
  * 另一种是基于成分的搜索，当然这个框架还提供了可用成分库
* 搜索空间：在给出的使用了补丁的程序中找到一个可用的补丁。就是找错误程序的修改版本叫做程序变体（它包括修改点，修改点对应的操作，代码源：所谓的成分）

==产生程序变体generate-program-variants==：

<img src="C:\Users\HDULAB601\AppData\Roaming\Typora\typora-user-images\image-20211025185702402.png" alt="image-20211025185702402" style="zoom:67%;" />

* 首先选择一个修改点。
* 然后对于选择的修改点选择一种修复运算op-j.在第四行有有个EP_OS,用来指定修复操作
* 程序变体（program-variants）：bug程序的修改版本，由修改点+修复操作+修改操作在修改点上所产生的代码
* 补丁：就是将错误程序与程序变体的更改提取出来的

==create-transformation 代码转换==：

这个方法用来使修改点与修改操作结合。属于算法2

<img src="C:\Users\HDULAB601\AppData\Roaming\Typora\typora-user-images\image-20211025192634356.png" alt="image-20211025192634356" style="zoom:67%;" />

* 如果这个操作需要成分，那么从成分池里拿元素。
* EP_IPD:用来插入构成成分库的方法
* EP_IS:c从成分池中选择成分的方法
* EP_IT:如何将成分和操作转换：成分转换方法

==产生程序变体Creation of program variants==

属于算法1

<img src="C:\Users\HDULAB601\AppData\Roaming\Typora\typora-user-images\image-20211025194134864.png" alt="image-20211025194134864" style="zoom:67%;" />

* 一旦创建了程序变体，这个框架会根据每个变体合成一个补丁，然后应用于正在修复程序的错误版本。
* ==注意程序变体不是一个程序，它只是一个更改==：synthesize-patch-from-variant(P, pv-i)这步骤就是在将程序变体应用到补丁中。
* EP_PV:怎么使用测试集TS来验证补丁，也就是说用什么验证过程，这里居然也有不同的策略
* EP_FF:指定验证过程的输出，以此来评估验证补丁的适应度输出。

==停止修复==：

* 找到n个合理的补丁：size（tsa-patchs）
* 迭代n次：nr-iteration
* 超出h的时间

## 7 文章亮点

给出一个框架，有可扩展的地方。

接下来列出本文重要的扩展点

1. 缺陷定位(EP_FL):

2. 修改点粒度(EP_MPG):根据修复方法比如（jGenProg是语句级的修复），所以会影响修复操作（对于jGenProg替换、删除、插入）

3. 搜索空间导航（EP_NS）：指用什么策略来找补丁
   * 穷举：对所有的修改点进行所有的修复操作
   * 选择：当穷举过大时，通过选择修改点和修复操作来降低复杂度，两种不同方向的策略（修改点和修复操作）分别也有扩展点：EP_MPS 、EP_OS 
   * 遗传编程
   
4. 修改点的选择（EP_MPS）：
   * 相同概率
   * 根据代码的可疑度选择不同的概率
   * 以可疑度进行降序表示
   
5. 修复操作空间的选择（EP_OD）：选四种操作空间择下列
   * 语句操作：插入、删除、替换
   * 逻辑运算
   * 条件语句的改变
   * 表达式的更改
   
6. 操作的具体的选择方法（EP_OS）

7. 成分空间的选择（EP_IPD）：

   * 与bug程序同一文件
   * bug的同一个包
   * 全局

8. 成分在确定的空间下的选择算法（EP_IS）

   * 均匀随机
   * 代码相似性
   * 基于变量频率的（不太清楚）

9. 成分转换（EP_IT）：在确定成分之后，如何将成分转换为修改点需要的形式

   * 不转换直接套用
   * 随机替换
   * 相似命名的变量之间的替换
   * 基于名称概率的替换

10. 补丁的验证方式（EP_PV）：

    这个扩展点还能度量程序变体的资源消耗（比较难实现）

    * 用给定的测试套件
    * 生成新的测试用例：使用的是MinImpact来生成测试用例

11. 适应度计算（EP_FF）

    它这里还停留在测试用例只是一个boolean的输出

12. 补丁优先级（EP_SP）：

    * 补丁按时间顺序
    * 按测试用例的运行结果

起初觉得这论文没水平，但是看了之后，发现用处还是有不少的。他提供了一个方向，未来的研究者可以从他的EP点中进行新的补充，以此来促进程序修复的进一步发展。

==相关工作==：

除了当前技术之外，弱测试集似乎不是主要的限制因素

