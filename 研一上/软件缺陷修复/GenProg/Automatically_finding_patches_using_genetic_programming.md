# 笔记模板1

## 1. 自我提问

1. 用了什么算法
2. 该算法是什么
3. 这个技术（算法）能够修复什么类型的缺陷
4. 算法是怎么应用到软件修复里的
5. 为什么找到一个成功的修复后需要结构差分算法和增量调试使它最小化还有如何最小化？
6. 算法的效果如何

## 2. 自我解答

1. 用的是遗传编程GP(Genetic Programming)

2.  遗传编程是利用程序对应的AST来实现对种群基因的变异，即每一个种群里的个体都由父类AST之间的变异而来，文中所用的遗传算子有两种：交叉和变异。直到有一个AST满足所有测试用例(用适应性这样的数据来说明)

3. 难说，论文里修了死循环、段错误(访问的内存超出了系统给这个程序分配的内存空间)

4. 

   (1) 首先这个算法需要被限制在一些条件下：当程序有缺陷时，它能够用程序的其他位置复制语句并且使语句适应添加在缺陷的位置；采用的遗传算法的突变和交叉只能出现在缺陷相关的程序区域。

   (2) 利用抽象语法树以及节点的权值来记录和评估每次使用遗传算法产生的变体的适应性。所谓的适应性就是这次变体通过的已经明确的成功测试用例和失败测试用例的加权和。

   (3) 在算法中权重(weight)是一组集合，由<语句，权重>这样的形式保存。假定成功或失败的用例经常访问的语句不是修复点，但是假定失败的测试用例至少访问一次的语句是一个合理的修复点

   (4) 上述都是初始化，开始修复的重点是选择遗传算子以及适应性的计算。其中适应性的计算过程是最耗费时间的

   (5) 将得到的修复后的解进行最小化，因为有一些修复后的语句是不需要执行的

5. 最小化一个成功修复是因为可能会执行没有用的语句，对结果不会造成任何影响，但是会吃内存、占用没有必要的时间。

## 3. 文章的核心问题与思路

​       文章最核心的贡献： 根据给出的测试用例，给出最小的修复；利用遗传编程来修复程序；从不同领域的项目中修复多个不同的bug。

核心：通过GP来实现对程序的修复。

大致思路就是找到一个在bug(程序块)附近的变体，这个变体避免了已知的缺陷还保留了该程序的主要功能。



## 4. 可能改进的地方

* 本文中修改的地方倾向于失败的测试用例访问的语句而不是成功的测试用例访问的语句。当bug出现的地方正是两者都访问过的语句时，怎么办？ 共同访问的语句一般不会把它作为出现bug的语句
* 如果程序的失败不仅仅是因为一个地方的bug，而是由多个错误共同引起的，将要如何修复。即使根据这个技术能够使单元测试全部通过，当进行集成测试的时候，系统却不能运行了或者不能达到预期的效果该怎么办？

## 5. 文章流程图

## 6. 算法流程图

1. 抽象语法树

   ```
   不依赖与具体的语法，而是将源代码的抽象语法结果用树的结构来表示。树上的每一个节点都是源代码的一种结构。     具体说明见https://blog.csdn.net/weixin_39408343/article/details/95984062
   ```

2. 遗传编程GP详解：

   https://blog.csdn.net/ocd_with_naming/article/details/98901749

   https://www.jianshu.com/p/ae5157c26af9

3. 算法流程：

   ![GP算法流程图](C:\Users\HDULAB601\Downloads\GP算法流程图.png)

5. 变异(mutation)流程:

   ```java
   1. 输入程序P以及它对应的路径
   2. 对P中每一对权值集合进行遍历,权值集合就是用例执行到的语句的集合
   /* 当这条语句没有被成功的用例执行，却被失败的用例执行时，可能性 == 1。 当这条语句同时被成功和失败的用例执行时，权值大小就是该语句变异的可能性大小，范围在0~1.
   */ 
   
      for each <stmti, proi>path
      op = choose{insert, swap, delete}
   //在这三种操作里选一个，概率为1/3。且操作的是一整条语句，比如插入一整条语句......
      if(op == swap)
          stmt2 = choose(P);//从整个P里找一条语句
          <stmti, proi> = <stmt2, proi>
       else if(op == insert)
           //在当前语句后加一条语句，将这两条语句当做一条
           <stmti, proi> = <{stmti,stmt2}, proi>
       else if (op == delete)
           //在AST中并没有删除这个节点，而是用null来改变节点的值.而且stmti可能会被选为stmt2
           <stmti, proi> = <null, proi>
      end for
      return 变异的P以及对应的路径
   ```

6. 在这里有一个全局突变率$$W_{mut}$$来决定这条语句是否突变

6. 交叉Crossover

   如同遗传编程的交叉一样。注：交叉的对象总是在当代种群个体与原始程序P进行，不在上一代变异个体里取。而且不是对所有语句交换，只有在P、Q程序中proi相同的语句才能交换

7. 适应度函数

   1. 对上述的方法生成的AST进行编译。

   2. 将编译的程序来测试给出的测试集。

      ![image-20210924095027766](C:\Users\HDULAB601\AppData\Roaming\Typora\typora-user-images\image-20210924095027766.png)

      说明：只有通过的测试用例才能被计算到fitness中。当AST无法被编译成程序时，fitness为0

      

8. 最小化修复的P

   没看懂，再看3.5

9. 实验

   接近一半的时间给了适应度的计算，30%的时间给了编译变体的AST

   在这个算法里，测试用例是很重要的，有一个好的成功的测试用例能够减少加权路径的长度，从而增加修复的成功率。

   

   
