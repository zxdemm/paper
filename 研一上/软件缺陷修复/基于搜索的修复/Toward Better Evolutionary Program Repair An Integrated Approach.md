# 笔记模板2

## 1. 文章解决的问题

1. 如何选择一个合理的搜索空间
2. 如何设计一个算法使它更有效地利用搜索空间
3. 如何解决补丁overfitting的问题
4. 分离了插入与交换操作的耦合度

#### 文章的贡献

1. 利用语句级冗余假设（操作都在语句级别）和PAR等修复模板结合来**==确定一个搜索空间==**

   1. 利用语句级冗余假设

      首先要清楚每条LBS（Likeed buggy statement ）都有对应的两个集合：replace（$$R_j$$） and insert($$I_j$$)。这两个集合都由语句组成，这些语句就是成分语句

   * 利用语句级冗余假设：首先是将LBS所在的包下的语句s进行遍历，如果s的变量和方法超过了LBS的方法和 变量的范围（与arja中的scope determine类似，就是可见变量和方法的范围）然后会用ARJA中的六条规则来确定这条语句是否能用作成分语句。

   * 但是即使符合了上述条件，还需要进行筛选。如果是插入操作，那么这条语句s必须与周围的上下文有一定的相关性，则要对插入的这条语句进行==上下文分析==。如果是替换操作，则应该与LBS有一定的相似性。以此再次筛选成分语句

   * 相似度计算公式：![image-20211014101145022](C:\Users\HDULAB601\AppData\Roaming\Typora\typora-user-images\image-20211014101145022.png)

     $$V_{LBS}$$指这条语句包含的变量的集合：如果有方法，则把方法返回的val对应的变量添加到集合

   * 相关性计算公式：![image-20211014101443151](C:\Users\HDULAB601\AppData\Roaming\Typora\typora-user-images\image-20211014101443151.png)

     $$V_{bef}\quad V_{aft}$$为k条语句的变量集合。k在该文章中默认为5

     sim和rel的值都要大于文章中默认的一个值才能通过s这条语句。

     流程图：

     ![image-20211014102720679](C:\Users\HDULAB601\AppData\Roaming\Typora\typora-user-images\image-20211014102720679.png)

2. 利用修复模板来确定搜索空间

   这部分还没有去了解，先放一放
   
3. 操作初始化：与araj差不多，仍然有一些约束，比如不删除return语句

4. * 补丁的表示$$x=(b,u,p,q)$$,b是指修复了哪个补丁，u是指用了哪个操作，p是replace集合，q是指insert集合

   * 多目标的对象仍然为原来的两个，不过适应度方法变得更加细粒度了。

     原先的适应度计算是以测试用例是否通过为基础的。也就是说测试用例只能给出true或false这样的作用，远远没有有效地利用起来。

     现在根据junit的断言方法来求得由测试用例得出的正确的输出与实际输出进行对比，用值来进行度量，叫做断言距离（assertion distance）。举例：

     1. 现在采用junit中的assertEquals(x,y,δ)，x是正确的输出，y是实际的输出，δ是正增量，该函数是断言两个数字的差是否在一个正增量的范围内。

     2. 断言距离公式：![image-20211017130238566](C:\Users\HDULAB601\AppData\Roaming\Typora\typora-user-images\image-20211017130238566.png)

        其中$$v(a)=a/(a+1)$$

     3. 定义好断言距离后，需要计算补丁x在测试用例上的失败的度量。

        ![image-20211017130808194](C:\Users\HDULAB601\AppData\Roaming\Typora\typora-user-images\image-20211017130808194.png)

        ![image-20211017132340269](C:\Users\HDULAB601\AppData\Roaming\Typora\typora-user-images\image-20211017132340269.png)

     ```java
     E（x，t）是一个测试用例t在当前补丁x上执行的几个断言函数的集合，也就是说每次执行一个测试用例时需要执行多个不同的断言函数。见上图
     ```

     那么h(x,t)分子：断言值之和，分母：断言函数的个数

     4. 确定了度量h之后，得出$$f_{2}(x)$$.

        ![image-20211017132716388](C:\Users\HDULAB601\AppData\Roaming\Typora\typora-user-images\image-20211017132716388.png)

   * 遗传算子的使用：对x补丁的四个部分全部使用半均匀交叉（HUX）。

   * 开始遗传

     初始化都是随机的。开始迭代后，直到满足条件为止（代数到达最大、找到补丁）。

     首先根据有N个数量的种群p产生N个数量的q。然后移除种群中的重复项（代表同一个补丁）。

     然后再通过crowding distance comparison（拥挤距离比较）的快速非支配排序 从p和q中挑选N个父代来生成下一代。
     
   * 补丁过拟合的处理
   
     两大功能：过拟合检测、补丁排序
   
     1. 过拟合检测：
   
        CIP（过拟合检测方法）基于一种假设：有bug的程序在合法的输入下(阳性测试用例)是正确的。
   
        过程：输入一个bug程序、一组k个阳性的测试用例、待测试的补丁
   
        首先用测试用例测试有bug的程序，然后保存它们的<input, output>.
   
        然后用补丁修补程序，再生成新的<input, output>，两个集合进行对比，如果有不同，则认为这个补丁是过拟合的。
   
        （这个方法是先将修复语句的位置所在的方法进行定位，在输入数据时，是保存这个方法中传入的参数，然后方法输出数据时，保存这个输出数据）
   
     2. 补丁排序
   
        对于补丁p，该补丁修改了D条LBS，以及每条语句的修复方法t（既有修复模板也有插入删除替换等操作）。
   
        对于p的排名设置三个指标。
   
        1. p修复的LBS的怀疑度之和![image-20211018161445578](C:\Users\HDULAB601\AppData\Roaming\Typora\typora-user-images\image-20211018161445578.png)
   
        2. 对于CIP中的两组<input, output>，进行类似于求断言距离一样，将k个断言距离求平均数。越小越好
   
           ![image-20211018161506293](C:\Users\HDULAB601\AppData\Roaming\Typora\typora-user-images\image-20211018161506293.png)
   
        3. 首先对t操作进行优先级设置，![image-20211018162100777](C:\Users\HDULAB601\AppData\Roaming\Typora\typora-user-images\image-20211018162100777.png)
   
           SR、SI、SD分别为替换、插入、删除操作。其余的是模板修复操作。
   
           优先级从左往右依次减小。将p中的操作的优先级进行求和，数值越大越好。
   
        两个补丁比较：优先看指标1，再看2，最后看3。都一致的情况下，越早发现排名越高。
     
        

## 2. 解决的思路



## 3. 核心知识点

## 4.程序功能说明

该工具大致流程算法

![image-20211014093210145](C:\Users\HDULAB601\AppData\Roaming\Typora\typora-user-images\image-20211014093210145.png)

## 5. 存在的问题

1. 过拟合的部分没有很好的处理
2. 整体性能如何？
3. 搜索空间合理吗（语句级冗余和修复模板效果、 相似度以及上下文关联度效果）
4. 寻找补丁的效果如何？（适应度函数的效果、插入和替换的成分语句解耦有没有好处）
5. 过拟合方法的性能如何

## 6. 改进的思路

其他可能的局部改善方法：

1. 修复成分来源：除了语句级冗余假设和修复模板，还可以用源代码存储库。难点在于如何从库中获取有效的成分
2. 替换与插入的相关性、上下文相关性可以用机器学习等技术进行完善
3. 适应度函数可以再通过外部信息来完善



2. 整体性能：由于有随机性，对于一个bug可能需要多次试验。对于defects4j的224个bug来说，可以修复106个bug。
3. 修复模板的作用比语句级冗余的效果好。相似度的使用提高了修复率
4. 适应度函数很优秀。插入与替换的成分语句集的解耦使进化搜索更加有效率。
5. CIP能过滤出49.9%的过拟合补丁。
