# 想法

## 过拟合补丁：

阳性的测试用例指的是在该软件下合法的输入的测试用例。比如加法软件，输入的值为实数。那么实数就是阳性的测试用例。虚数就是阴性的测试用例

1. 给出足够的错误的测试用例，使得bug暴露地足够多(Defects4j给定了bug)

2. 用手写的补丁与APR补丁进行比较

3. 得到补丁后动态生成测试用例，再对补丁进行检测（这个想法已经被人提出来了）:

   想法来源：《Identifying Patch Correctness in Test-Based Program Repair》

4. 基于测试输入的启发式检测。根据测试输入的执行路径来对新生成的测试输入和补丁进行分类。

   想法来源：《Identifying Patch Correctness in Test-Based Program Repair》

   ==其中测试执行的公式可以按照bug语句的可疑度来添加权值==

## 遗传编程设计中的适应度计算

1. 充分利用测试用例的输入与输出，而不是单纯地看测试用例是否通过
2. 可以用人工智能来计算损失函数

## 成分语句

1. 编写一个数据库，使得可以用来充当成分语句，借此来修复小型的程序

# 测试用例

1. 去除冗余测试用例：利用测试用例的执行路径来去除相同类型的测试用例。比如用最长公共子序列、Levenshtein距离、汉明距离来比较两条执行路径
2. 在进行过拟合验证的时候，一般需要产生新的测试用例。那么如何确定这个测试用例是通过还是失败需要有新算法来完成。最好不是用人工来分类

## 测试用例生成工具

1. Randloop:随机测试生成
2. KATCH
