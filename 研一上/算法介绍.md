# 算法介绍

输入：一组测试集、源程序、补丁（程序形式）

输出：若是过拟合补丁，给出补丁的种类以及三元组$$<\ell,b,?>$$（三元组是为了告诉使用者究竟是哪里出错了）。如果正确，则判断为正确。

过拟合补丁分三种，a ： 未完全修复、b：引入新的错误、ab： 前两者都有。

本算法基于一个假设：对于失败的测试用例来说，使用补丁前后得到的三元组的值是不同的。对于成功的测试用例来说，使用补丁前后得到的三元组的值是相同的。并且成功的测试用例在原程序中的程序行为是完全正确的。（否则完全不能判断）

```
北大文章基于的假设：
1. PATCH-SIM：应用补丁前与补丁后的程序，对于成功的测试用例来说是没区别或相似的。但是对于错误的补丁是有很大的区别的。这是一个基准
2. TEST-SIM：两个测试用例有相似的执行时，那么两个都触发了相同的错误或都正确。这个可以用来生成新的测试用例

二者相同的地方就是不需要Oracle来判断测试用例的输出是否正确。
```



## 1. 概念介绍

### 1.程序抽象状态

设经过补丁修改的方法为fixMe（补丁程序与bug程序有差异的方法），在该方法中表示唯一的语句记为$$\ell$$，fixMe对应的类FC。对于每一条语句$$\ell$$都记录每一次执行测试用例时的表达式的值，该集合为$$M_\ell$$。

比如：

* 数值型、布尔类型的表达式
* 引用类型的对象标识符

#### 表达式

$$E_\ell$$表示为在$$\ell$$处所有的基本表达式的集合

比如：

* 在fixMe中声明且在$$\ell$$中可见的局部变量（包括fixMe的参数）
* 类FC中的可见的属性
* $$\ell$$中可以计算的fixMe的所有表达式（计算时不会改变被计算变量的抽象状态）

$$X_\ell$$表示在$$\ell$$中的拓展表达式的集合，设$$r属于E_\ell$$

比如：

* $$r.f()$$, r的无参数方法。且返回的值是可以记录的
* $$r$$是this时，$$r.a$$也是表达式

### 2. 三元组s = $$<\ell,b,?>$$

b是一个在$$\ell$$上的布尔表达式，？是b的值

b是通过$$M_\ell$$对应的同类型表达式进行对比而得到的。比如有integer类型a、b属于$$E_\ell$$。则有表达式$$a>b、a<b、a>=b、a<=b$$

#### 三元组可疑度

两个维度：b的依赖性$$ed_s$$、动态评分$$dy_s$$.

* 两个表达式的相似性$$ed_s$$

  当b在$$\ell$$前后的语句出现越多，则$$ed_s$$的值越多（这个值是用来测量s中状态变化的程度）

* 当失败的测试用例在s处更多被计算时，$$dy_s$$的值就越大，否则就越小

可疑度公式：
$$
2/({ed_s^{-1}}+dy_s^{-1})
$$

## 2. 算法流程

![过拟合补丁算法流程](C:\Users\HDULAB601\Downloads\过拟合补丁算法流程.png)

1. Snapshot finder：

   输入bug程序与原始数据集$$T_{original}$$，通过jaid中的缺陷定位技术得到可疑度最高的snapshot。可疑度的计算公式为
   $$
   2/({ed_s^{-1}}+dy_s^{-1})
   $$
   并且保存每个测试用例在该snapshot的状态，也就是说$$<\ell,b,?>$$中？的值。设这个结果的集合为$$S^{ori}_\ell$$

   ```
   这一步有两个作用
   1. 为了下一步生成新的测试用例提供标准，从而生成失败的测试输入
   2. 为了第三步补丁程序运行测试集后得到的snapshot集合进行对比，从而判断补丁的类型
   ```

2. Test generation：

   生成新的测试输入，使得该测试输入在$$\ell$$处得到的b的值与s的值相等，从而将新的测试输入归类为失败的测试输入。将该测试输入添加到测试集，得到新测试集$$T_{new}$$,并且将对应的snapshot的值添加到$$S^{ori}_\ell$$中。==符号执行==

   ```
   北大文章生成的测试输入的标准是：新的测试输入要覆盖至少一处补丁修改的方法。而北大文章对新测试输入的分类方法是运行bug程序，将新测试输入的执行路径与原测试集进行对比，按照执行路径的相似度对测试输入进行分类
   ```

3. Detection：

   在这一阶段，利用补丁程序运行$$T_{new}$$, 获取第一步中确定的s中对应的表达式的值，结果集合为$$S^{new}_\ell$$。

   此时设两个int变量：$$N_f和N_p$$。将$$S^{ori}_\ell$$与$$S^{new}_\ell$$进行对比。

   $$N_f$$表示两集合间，对于失败的测试输入，snapshot的值相同的数量。

   $$N_p$$表示两集合间，对于成功的测试输入，snapshot的值不同的数量。

   补丁分类公式：
   $$
   detection(p)= \begin{cases} a& N_f>0\bigwedge N_p = 0\\ b& N_f=0\bigwedge N_p>0\\
   ab& N_f>0\bigwedge N_p>0\\ correct& N_f = N_p = 0\end{cases}
   $$
   
   

a:未完全修复. b:引入新错误.   ab:两种都有

```
   北大文章在对补丁进行分类时，基于执行路径的不同而只能给出补丁是否正确。并且在判断时，有一个人为设定的阈值，会影响最终结果的判断。
   而基于表达式的方法可以进一步将补丁进行分类，而且完全没有人为设定的数据，所有数据由程序和测试集提供。
```



### 算法改进

1. 三元组改为五元组$$<\ell, b, ?, i, v>$$.

   * i表示为测试用例的序号
   * v表示b这个表达式在i测试用例的真实值

   那么此时，？已经是新生成测试用例的标准了。v才是最后一步比较bug程序与补丁程序的数据。

   原因：可能找不到一个完美的表达式b，使得成功的测试用例都为true， 失败的测试用例都为false。

2. 补丁程序中怎么找到表达式？应该在最后不同的前一句处计算表达式的值

   ```
   buggy：
   int x = 0;
   int y = 1;
   
   x = y - x;
   
   a
   b
   patch:
   int x = 0;
   int y = 1;
   
   x = x + 2;
   y = y + 3;
   
   b
   
   ```
   
   

## 算法详解

## 1. Snapshot finder$$<\ell, b, ?, i, v>$$

这一步是为了将程序中的不变量五元组找到。以及保存这个五元组的每项元素的值。

具体看jaid中这个三元组是如何运行的。

1. 首先要在源代码中的做一个新的类，那个类是一个五元组。
2. 然后再保存下测试用例的结果

## 2. Test generation

利用符号执行。而且不需要用符号执行将整个程序的约束都添加到约束求解器里，只要程序到达$$\ell$$,然后将$$b == ?$$这个约束添加到求解器里，那么就能得到一个测试输入。而且在围绕五元组的核心定义下，是不太会出现符号执行路径爆炸的情况。

如果不能求解，那没办法，只能用原来的测试集。

## 3. Detection

已经说明了



### 算法的实现

1. 建立五元组

   详见Fix类中的

   ```java
   public static Map<TestExecutionResult, Boolean> printTestValue(StateSnapshot stateSnapshot, List<TestExecutionResult> testResults, JavaProject javaProject)
   ```

可以做到

2. 生成新的测试用例

   * 之前是打算用符号执行，但是发现好像是一个新的领域，很难实现。如果有需要，可以在以后去实现
   * 利用当前的测试工具生成测试输入，然后选出满足可疑表达式值的测试输入

   **具体怎么搞**：通过将javaProject的路径读取待测试程序或者是待测试类。然后运行Evosuite工具生成测试输入。然后对生成的测试用例进行过滤，选取满足三元组值的测试用例，添加到测试集

3. 运行补丁程序：buggy、patch

   什么时候找程序表达式：
   
   * 当表达式在C处发现，而两个程序不同点在C前面，那么patch仍旧在C处计算表达式的值
   
     ```
     buggy：       patch：
     A;            A;
     B;            D;
                   E;
     C;            C;
     ```
   
   * 当表达式在C处发现，不同点在C之后，就判断过拟合
   
     ```
     buggy：       patch：
     A;            A;
     C;            C;
     D;            B;
     o
     ```
   
   * 当表达式在C处发现，不同点在C处，那么patch仍旧在C处计算表达式的
   
   * 当表达式在C处发现，但是C被删除了，则在C的下一处计算表达式
   
   最后先决定在修改点的下一处（下一条语句）来查找三元组

在补丁程序中如何确定哪条语句应该被监听（从这条语句中计算三元组的值）：

1. 从bug程序和补丁程序比较，首先从正向遍历，直到遇到不同的语句，记录此时补丁程序中的语句为start。再反向比较，直到第一次不同的语句，记录此时补丁程序中的语句为end。
2. 判断以下情况：
   * 如果start包含语句end，即start是if块、for、while等语句，end是这些块中的语句，则读取这个块的下一句。
   * 如果start和end不是包含关系，那么读取end的下一句
   * 如果不存在下一条语句，则读取end语句
   * 假如end语句在start语句前面，则补丁是一个删除操作，读取start语句就行。



程序的数据集有

1. https://github.com/qixin5/DiffTGen文章Identifying Test-Suite-Overfitted Patches through Test Case Generation
2. https://github.com/yyxhdy/defects4j-patches 文章：arja
3. https://github.com/Amirfarhad-Nilizadeh 文章Exploring True Test Overfitting in Dynamic
   Automated Program Repair using Formal Methods
4. https://github.com/anonymousICSE2019/patchcorrectness 文章On_Reliability_of_Patch_Correctness_Assessment.pdf的数据集



现在遇到的问题：如果一个测试用例有多个断言语句，有时候是一个断言出错，有时候是多个断言错误。这会导致判断补丁的失败
