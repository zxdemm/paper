# Software healing AND Software repairing

### 1. 相关概念：

* Software healing : 现场检测软件故障，做出相应来使系统恢复正常的运行。不涉及系统源代码的修改。
  1. 所以它更强调软件的可用性，不会永久消除软件缺陷，只是会减少缺陷带来的影响
  2. 而且会去预防软件出现故障
  
* Software repairing：检测软件故障，定位可以修复的地方。在系统内部修复，会对源代码进行修复
  1. 关注的是永久修复软件缺陷，而且
  2. 面对软件执行失败的例子时，会提取信息来识别和修复故障。不会去防止软件的故障
  
* 由于两者的特性，第一种用来软件运行的场景，第二种用来协助开发人员来开发软件进行软件缺陷修复

* 修复过程对比：

  |                       SoftWare healing                       |      Softwore repairing       |
  | :----------------------------------------------------------: | :---------------------------: |
  |                         1. 进行修复                          | 1. 定位导致出现错误的代码位置 |
  |                    2. 对修复操作进行验证                     |          2. 进行修复          |
  | 可能会重复进行验证与修复操作，但是必须快速修复，有一定的时间限制 |       3. 验证是否被修复       |

  修复结束条件：

  * SoftWare healing：修复成功或没有进一步操作的可能
  * Softwore repairing： 修复成功或没有进一步操作的可能或分配给修复程序的时间结束

  ## 2. Software repairing

  ### 1. 定位

  * 故障定位(fault localization) : 定位错误的语句，这种情况下会去修复错误的语句

  * 修复处定位(fix locus localization) : 与上一个不同的是，它要找到一个合适的地方对错误的语句进行一个补偿修复，来抵消错误语句的错误影响，而不是去修改错误语句使他变成正确的语句。所以找到的位置与故障的位置无关

  ### 2. fault localization故障定位

  * SBFL算法：该算法执行的粒度级别与修复的级别一致。通过在测试期间的信息来识别可能出错的位置

  * SBFL算法中的几个参数：failed(s):在所有失败的测试用例F中，s这条语句执行了几次，是否执行的标记是X。

    totalfailed是指这几个测试用例中哪个是失败的测试用例，也就是最下面F的个数

    以此类推

  ### 3. Fix locus localization修复处定位

  1. **基于模型的修复处定位**

     首先运行正确的测试用例，然后建立根据程序运行期间是如何运用类的模型。然后再运行错误的用例，如果执行错误且违反了之前的模型，那么哪里违反了模型的代码就是程序故障的位置

  2. **天使修复定位**

     * 它会使忽略条件表达式的值，会将不会被程序通过的测试用例在分支处走上不一样的程序执行，如果按照上述的分支通过了测试用例，则使该测试用例通过的条件值叫天使值。该if语句会被选择。
     * 当缺少if语句时，它会跳过一条或多条语句的执行来检查失败的用例能否成为成功的用例。如果用例因此通过了，则会生成一些if条件来控制必须跳过的语句

  ### 4. 生成修复并验证修复方案（在文中的第六章）

  1. 生成并验证方法：

     生成S解决集合：

     * 针对待解决的P问题，它会产生一个S解决方案的集合。
     * 怎么生成S集合？ 利用一组更改操作。
     * 有三种操作：原子更改：在单个点上进行修改、预定义模板操作：根据潜在的复杂预定义模板更改、基于示例的模板操作：根据从历史数据中提取出来的模板进行操作

     操作的详述：

  #### 4.1 原子更改操作(Atomic Change Operators)

  作为最简单的更改操作，它只要去修改程序被定位的位置。这个方法是用抽象语法树AST（将要修改的程序作为抽象语法树）。	

  ##### 4.1.1 通用的基于搜索技术(General Search-sed Techniques)

  使用三种原子更改操作：删除AST(抽象语法树)的一个语句、插入从AST中随机复制的语句、使用从AST的随机位置复制的元素修改AST的元素。

  在表中，其他的技术都是当AST 中存在元素时，即程序中包含修复所需的语句，否则就无法修复故障。但是JAFF是个例外，它具有随机生成新语句的能力。

  GenProg、Marriagent、RSRepair和SCRepair严重依赖于这样一种假设:生成修复所需的语句在正在修复的程序的某个地方

  ##### 4.1.2 通用的蛮力技术

  无

  #### 4.2 预定义模板(Pre-DefinedTemplate)

  使用模板使开发人员定义复杂的更改模式，这种模式会在程序的多个位置影响程序。

  ##### 4.2.1 针对并发缺陷的基于搜索的技术

  ##### 4.2.2 通用的蛮力技术

  蛮力技术定义了一旦应用到程序后就可能修复程序缺陷的模板。修复过程是将每个模板应用到每个可能的位置，直到程序被修复或超时。

  SPR技术修复过程：首先选择一条语句和一个模板。然后向现有条件添加子句和生成新的条件，使失败的用例转化为通过的用例

  ##### 4.2.3 缓冲区溢出故障的蛮力技术

  跳过这部分

  #### 5 语义驱动的修复

  对问题P进行形式化编码，比如编成一个公式，然后这个公式的一个解就是问题p的解决方案。而且不用对这个解进行验证。

  有三个过程：

  * 行为分析(behavioral analysis):它分析要修复的程序，来提取程序正确或错误行为的语义信息
  * 产生问题(problem generation):利用上述的信息生成待解决问题的表达形式
  * 修复生成活动(fix generation):试图解决上述产生的问题

  这个算法通常处理特定的缺陷类，而不是一般的缺陷

  ##### 5.1 程序合成

  生成一个程序（函数），使得所有输入的数据都能通过这个程序得到一个目标的输出。通过程序合成，我们在最初的合成算法中可以得到的是输入输出对以及组成这个程序的组件(比如加减乘除的方法)

  ##### 5.2 通用技术：针对table3中的第一行（general）

  * SemFix算法用一个符号表达式替换正在修复的程序中的表达式，使得给出的几种测试用例都能够按照预期的结果输出（测试用例是通过或者失败）
  * DirectFix算法与SemFix类似，将有缺陷的程序转换成对行为进行编码的公式f，将失败的测试用例转换为与f进行与操作而无法满足的一组约束O。修复过程是修改公式f，使得修改后的f和O进行与操作能够满足
  * Angelix


#### 6 修复推荐（第7章）

该技术不会向前面一样产生修复的技术，只是提出一些可能来修复故障的操作

#### 7经验证据

成果不多，虽然有的已经应用与上万行的程序了，但大多数情况下不能扩展到百万条代码的程序
