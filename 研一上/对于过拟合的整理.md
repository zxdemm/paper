# 希望解决的问题

如何判断一个补丁是否过拟合？

在软件修复领域，我们无法知道test oracle，完全靠测试集中的测试用例是否通过来判断一个补丁是否正确。而对一款软件或程序来说，它们是不能被完全测试的。或者说给定的测试集都是弱测试集（绝大部分的修复工具只要求至少有一个失败的测试用例）。所以如果依靠观察测试集中的测试用例是否全部通过来判断补丁是否正确是会存在补丁过拟合的问题。而我要解决的是如何判断补丁的过拟合问题，且减少Oracle不足的影响，自动判断。

实践过程中的依据：程序员在寻找bug的时候，一般是调试，查看某个变量的值。这个依据是程序分析技术的一种：动态不变推理。就是找程序不变量，有挖掘工具：Daikon

如何定位错误的表达式《A family of code coverage-based heuristics for effective fault localization》、给我启发的文章《Contract-Based Program Repair without the Contracts》、《Identifying patch correctness in test-based program repair》

# 关于过拟合补丁现状

一般来说，基本思想仍然是扩充测试集，尽量增强测试集。然后用加强后的测试集和不同的算法进行检测

## 如何过拟合补丁的检测

* Arja采用手工评价补丁的正确性

* Arja-e：该工具基于一个假设==即使是一个bug程序，它也可以使positive test cases运行成功（输出正确）==

原文：

```
We propose a new overfit detection approach called CIP, which is based on the assump-
tion that even a buggy program can function correctly on the test inputs encoded in the
positive test cases.

positive test cases: 面对系统或程序应该完成的事情而设计的测试用例
negative test cases: 面对系统或程序不应该完成的事情而设计的测试用例

举例：一个程序只计算0~100以内数字。正向的测试用例：5 + 10， 反向的测试用例 101 + （-1）


```



<img src="C:\Users\HDULAB601\AppData\Roaming\Typora\typora-user-images\image-20220302192923576.png" alt="image-20220302192923576" style="zoom:67%;" />

​      Arja-e的解决方法（检测过拟合）：

​      一个bug程序、一组正测试用例、一个可信的补丁（这个补丁已经通过了测试集）。首先确定补丁修改bug程序中的哪个方法的位置。然后运行正测试用例，在确定位置的方法里获取大量的输入-输出对。==此时的输入-输出已经与测试用例的输入输出不太一致。==根据假设，这些输入-输出都反映正确的输入-输出。然后将补丁嵌入程序，得到修复后的程序。也运行正测试用例，获取已定位的方法输入-输出对。最后进行这两种输入-输出对的比较。如果存在一对输入-输出没有一致，则将该补丁视为过拟合。

### ==找出的缺点：==

当测试集只有一个失败的测试用例，而且该测试用例为负测试用例。比如上述图中的例子。Arja-e只能再对正测试用例进行检查。如果该补丁只是刚好修复了针对唯一的负测试用例，那么在过拟合检查步骤中就失效了。只用正测试用例具有较大的局限性



上述的方法只是Arja-e中的检查过拟合补丁，接下去为了再次缓解过拟合，作者进行补丁的排序，排名越靠前则补丁正确率越高。

![image-20220302202959712](C:\Users\HDULAB601\AppData\Roaming\Typora\typora-user-images\image-20220302202959712.png)

对于上述两种过拟合的检查方法，作者给出了比较。当开发人员有精力时，用第一种；否则使用补丁排名。

文章给出最新的过拟合检查只能检测50%的过拟合补丁《 Identifying test-suite-overfitted patches through test case generation》、《Identifying patch correctness in test-based program repair》

##### 实验

本文使用CIP（自己的过拟合检查算法）和北大的程序执行路径（XA）的方法进行对比。

<img src="C:\Users\HDULAB601\AppData\Roaming\Typora\typora-user-images\image-20220304100358833.png" alt="image-20220304100358833" style="zoom:67%;" />

三个不同的工具（ARJA-e、jGenProg、jKali）生成错误补丁97个，正确的补丁25个。CIP将48个错误补丁识别出来，XA排除44个错误补丁。CIP排除了3个正确补丁，而XA排除了8个正确补丁。综合来看，CIP的效果比较好。



* XA《Identifying Patch Correctness in Test-Based Program Repair》

  生成新的测试输入，执行路径与之前的测试集进行对比，利用算法将测试进行分类，再进行补丁的分类。

  基于程序执行的行为相似性来自动判断补丁正确性。实验结果表明能在139个补丁集上分辨56%左右的过拟合补丁。

  在这篇文章中存在一个问题：会将正确的补丁归类到过拟合补丁中，因为没有正确的oracle。==在Arja-e的实验中已经验证，会将正确的补丁判断为过拟合==

  该文章有两种核心的启发式判断，新生成的测试用例（不需要关注测试输出）、程序在使用补丁后执行路径的变化程度。
  
* 过拟合补丁缓解《Alleviating patch overfitting with automatic test generation  a study of feasibility and effectiveness》：

  本文提出了过拟合补丁的三个种类：a（未完全修复错误）、b（修复原来的错误，引入新的错误）、ab（引入新错误也未修复原有错误）

  这个方法是针对基于语义修复的。求解器对于当前给出的测试集不断地求解，然后生成新的测试用例。当新测试用例满足求解器中的约束，则将测试用例添加到测试集中。然后在用求解器等工具对原有的过拟合补丁进行修改，缓解过拟合程度。

* 《Exploring True Test Overfitting in Dynamic Automated Program Repair using Formal Methods》：

  通过JML来规范程序的行为，将程序分割成一个个单元，每次一个单元的输入与输出都被规范。理论上是真正检测过拟合。

  缺点：jml无法应用到大型系统和项目中，只能在某个小程序中使用。

# 基本思路

过拟合补丁分三种，a ： 未完全修复、b：引入新的错误、ab： 前两者都有。

基本思想：寻找程序中的保持不变的表达式（依可疑度排序），以此来判断一个补丁是否过拟合。

输入：一组测试集、源程序、补丁（程序形式）。

输出：若是过拟合补丁，给出补丁的种类以及三元组$$<\ell,b,?>$$（三元组是为了告诉使用者究竟是哪里出错了）。如果正确，则判断为正确。

算法（文字）：

1. 首先用测试集跑一遍源程序，通过jaid中的定位技术找到可疑的三元组s。==（三元组取可疑度最高的1~3个，实验过程中分1个、2个、3个，之后可以分析三元组数量对正确性的影响）==
2. 用测试用例生成工具来扩充测试集，扩充的是失败的测试用例。==新生成的测试用例在三元组中的表达式的值必须与失败的测试用例一致==。扩充的测试用例数量也可以进行改变
3. 用扩充后的测试集执行补丁程序。将第一步中保存的三元组与执行补丁程序中对应位置的三元组进行对比，如果对于成功的测试用例有不一致，或失败的测试用例一致，则判断补丁为过拟合。（测试集收集的三元组的值组成一个向量）

# 注：

1. 如何生成测试用例，使得快速的得到一个表达式与失败的测试一致的值的测试用例：利用论文《Identifying Test-Suite-Overfitted Patches through Test Case Generation》中利用语义间的不同，生成的测试用例执行路径（原程序、补丁程序）不同，应该是可以较快生成符合条件的测试用例。

   在文章中，生成的测试用例是覆盖在补丁程序上的，就是说执行路径一定按照补丁程序的上的。我的方法是需要覆盖原程序的。

2. 另一种生成测试用例：类似于生成等价类一样的方法。根据测试用例的类型以及三元组中表达式比较的类型（比如a > b,其中ab是int）

   数值类型的比如a：a++; a--； 2 * a; a / 2;

   字符串str： str + str； str去尾；改大小写； 

   数组：类似于字符串

   如何给出正确的测试输出：不需要，只需看表达式的值是否变化。

3. 希望得到性能上的改进：第一步找三元组需要花费很大的时间（很难改进），生成测试用例也就那样（第一种方法会比第二种快？）执行速度是一个很大的问题。（Identifying Test-Suite-Overfitted Patches through Test Case Generation这篇文章平均3分钟左右判断一个补丁）

4. 还有一个问题：三元组匹配的问题：原程序在补丁修改后，在原位置找不到表达式怎么办？

   在修改的地方的前一句，任何同一个测试用例的表达式总是一致的，当出现第一次表达式不一致的时候说明程序出现不同了。此时查找补丁程序中第一次出现的s。可以进行比较了。

5. 还可以在程序执行结束的前一行，重新计算一下表达式的值，以此来重新比较。
