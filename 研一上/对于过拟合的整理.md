# 希望解决的问题

如何判断一个补丁是否过拟合？

在软件修复领域，我们无法知道test oracle，完全靠测试集中的测试用例是否通过来判断一个补丁是否正确。而对一款软件或程序来说，它们是不能被完全测试的。或者说给定的测试集都是弱测试集（绝大部分的修复工具只要求至少有一个失败的测试用例）。所以如果依靠观察测试集中的测试用例是否全部通过来判断补丁是否正确是会存在补丁过拟合的问题。而我要解决的是如何判断补丁的过拟合问题。

# 关于过拟合补丁现状

## 如何过拟合补丁的检测

* Arja采用手工评价补丁的正确性

* Arja-e：该工具基于一个假设==即使是一个bug程序，它也可以使positive test cases运行成功（输出正确）==

原文：

```
We propose a new overfit detection approach called CIP, which is based on the assump-
tion that even a buggy program can function correctly on the test inputs encoded in the
positive test cases.

positive test cases: 面对系统或程序应该完成的事情而设计的测试用例
negative test cases: 面对系统或程序不应该完成的事情而设计的测试用例

举例：一个程序只计算0~100以内数字。正向的测试用例：5 + 10， 反向的测试用例 101 + （-1）


```



<img src="C:\Users\HDULAB601\AppData\Roaming\Typora\typora-user-images\image-20220302192923576.png" alt="image-20220302192923576" style="zoom:67%;" />

​      Arja-e的解决方法（检测过拟合）：

​      一个bug程序、一组正测试用例、一个可信的补丁（这个补丁已经通过了测试集）。首先确定补丁修改bug程序中的哪个方法的位置。然后运行正测试用例，在确定位置的方法里获取大量的输入-输出对。==此时的输入-输出已经与测试用例的输入输出不太一致。==根据假设，这些输入-输出都反映正确的输入-输出。然后将补丁嵌入程序，得到修复后的程序。也运行正测试用例，获取已定位的方法输入-输出对。最后进行这两种输入-输出对的比较。如果存在一对输入-输出没有一致，则将该补丁视为过拟合。

### ==找出的缺点：==

当测试集只有一个失败的测试用例，而且该测试用例为负测试用例。比如上述图中的例子。Arja-e只能再对正测试用例进行检查。如果该补丁只是刚好修复了针对唯一的负测试用例，那么在过拟合检查步骤中就失效了。只用正测试用例具有较大的局限性



上述的方法只是Arja-e中的检查过拟合补丁，接下去为了再次缓解过拟合，作者进行补丁的排序，排名越靠前则补丁正确率越高。

![image-20220302202959712](C:\Users\HDULAB601\AppData\Roaming\Typora\typora-user-images\image-20220302202959712.png)

对于上述两种过拟合的检查方法，作者给出了比较。当开发人员有精力时，用第一种；否则使用补丁排名。

文章给出最新的过拟合检查只能检测50%的过拟合补丁《》

