# 过拟合补丁强化

基础：获得snapshot，以及分辨出过拟合补丁

**第二个创新点的主要目标：** 如何实现过拟合补丁的增强，最基本的目标是使过拟合补丁朝正确的补丁更近一步，高级目标：增强后的补丁是正确的补丁。

过拟合补丁排序：对A,B,AB的错误的严重性进行排序（严重性：A <B <AB，因为从现有的测试集也好，还是基于实际开发环境来看，一个程序员写出了通过测试用例数量比失败测试用例数量还要少的bug程序时，这个bug程序不如重新写，没有必要修复。所以说，如果引入了回归错误，还不如不修改）。还记得第一个论文里的假设吗==补丁均是能够通过测试套件的，bug程序中通过的测试用例反映了程序的正确行为，失败的测试用例反映了程序的错误行为==，说明bug程序运行通过测试用例，这期间的程序行为是正确的。==为什么对过拟合补丁根据类别排序，因为这是只有我才有的特色，唯一对过拟合补丁实际细分==（为了对比，我需要收集补丁排序的各种算法，一般修复工具都有自己的方法）。

强化一个过拟合补丁的流程类似与bug修复

1. 缺陷定位
2. 强化补丁
3. 过拟合补丁验证

其中缺点定位已经被第一个点确定，即snapshot中的语句位置以及布尔表达式。

## 强化补丁

根据过拟合补丁类型的不同，我们有不一样的强化操作。

针对**A**类型：

```java
if(snapshot成立)｛
	强化语句；
｝
过拟合补丁语句；
```

因为A类型只是未修复原来的错误程序，这说明了只有failing test在补丁中没有正确的程序行为，所以我们对

